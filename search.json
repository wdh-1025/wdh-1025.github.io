[{"title":"app增量更新","url":"http://www.68blog.cn/2016/11/06/4/","content":"<h2 id=\"写在前面\"><a href=\"#写在前面\" class=\"headerlink\" title=\"写在前面\"></a>写在前面</h2><p><font color=\"red\">本文运行环境为windows,其他运行环境请自行百度</font><br>本文带你一起实现android增量更新(并非热修复)，主要都是一些工具的实现，权当记录，也方便以后自己查看；<br>首先什么是增量更新？<br>顾名思义，就是只更新增加部分，一个app有几百M，但是实际修改只有几M或者更小，那么我们就只要下载差异部分进行合成更新即可，这样可为用户减少很大的流量流失。</p>\n<p>把整个流程细化为几个关键点：</p>\n<ul>\n<li>服务器生成差异文件</li>\n<li>app提取当前安装应用并与差异文件进行合并，生成新的apk</li>\n<li>调用系统安装</li>\n</ul>\n<p>只有第二点稍微有点难度，但是已经有工具帮我们实现了，SO…难度=0；</p>\n<h2 id=\"服务器生成差异文件\"><a href=\"#服务器生成差异文件\" class=\"headerlink\" title=\"服务器生成差异文件\"></a>服务器生成差异文件</h2><p><a href=\"http://download.csdn.net/detail/z191726501/9651809\" target=\"_blank\" rel=\"external\">下载bsdiff和bspacth</a>并切换到对应路径<br>准备两个apk，old.apk和new.apk(old.apk为旧的apk，new为更新后的apk)</p>\n<ul>\n<li>生成增量文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bsdiff old.apk new.apk patch.patch</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>这样就生成了一个增量文件patch.patch</p>\n<ul>\n<li>增量文件patch.patch和old.apk合并成新的apk<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">bspatch old.apk new2.apk patch.patch</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>查看文件md5值可以证明两个文件是否一样<br>目前为止服务端已经完成生成增量文件</p>\n<h2 id=\"客户端合成应用\"><a href=\"#客户端合成应用\" class=\"headerlink\" title=\"客户端合成应用\"></a>客户端合成应用</h2><p><font color=\"red\">需要设置ndk运行环境</font><br>接下来我们要提取本地应用apk，这个相对简单，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static String extract(Context context) &#123;</div><div class=\"line\">        context = context.getApplicationContext();</div><div class=\"line\">        ApplicationInfo applicationInfo = context.getApplicationInfo();</div><div class=\"line\">        String apkPath = applicationInfo.sourceDir;</div><div class=\"line\">        return apkPath;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>制作bspatch so，新建类，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class BsPatch &#123;</div><div class=\"line\">    static &#123;</div><div class=\"line\">        System.loadLibrary(&quot;bsdiff&quot;);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public static native int bspatch(String oldApk, String newApk, String patch);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>同时需要在module的build.gradle下面增加：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\">\t...</div><div class=\"line\">\tdefaultConfig &#123;</div><div class=\"line\">    \t\tndk &#123;</div><div class=\"line\">        \t\tmoduleName = &apos;bsdiff&apos;</div><div class=\"line\">    \t\t&#125;</div><div class=\"line\">\t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接下来需要编写C代码了，当然并非自己编写，bsdiff已经提供给我们了，把之前下载的bsdiff中的bspatch.c拷贝进去并新增一个方法</p>\n<p><font color=\"red\">注意方法名“JNICALL Java_com_addupdate_BsPatch_bspatch”，命名是有规则的，相对简单</font><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">JNIEXPORT jint JNICALL <span class=\"title\">Java_com_addupdate_BsPatch_bspatch</span></span></div><div class=\"line\">        <span class=\"params\">(JNIEnv *env, jclass cls,</span></div><div class=\"line\">         jstring old, jstring <span class=\"keyword\">new</span>, jstring patch)&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> argc = <span class=\"number\">4</span>;</div><div class=\"line\">    <span class=\"keyword\">char</span> * argv[argc];</div><div class=\"line\">    argv[<span class=\"number\">0</span>] = <span class=\"string\">\"bspatch\"</span>;</div><div class=\"line\">    argv[<span class=\"number\">1</span>] = (<span class=\"keyword\">char</span>*) ((*env)-&gt;GetStringUTFChars(env, old, <span class=\"number\">0</span>));</div><div class=\"line\">    argv[<span class=\"number\">2</span>] = (<span class=\"keyword\">char</span>*) ((*env)-&gt;GetStringUTFChars(env, <span class=\"keyword\">new</span>, <span class=\"number\">0</span>));</div><div class=\"line\">    argv[<span class=\"number\">3</span>] = (<span class=\"keyword\">char</span>*) ((*env)-&gt;GetStringUTFChars(env, patch, <span class=\"number\">0</span>));</div><div class=\"line\">    <span class=\"keyword\">int</span> ret = patchMethod(argc, argv);</div><div class=\"line\">    (*env)-&gt;ReleaseStringUTFChars(env, old, argv[<span class=\"number\">1</span>]);</div><div class=\"line\">    (*env)-&gt;ReleaseStringUTFChars(env, <span class=\"keyword\">new</span>, argv[<span class=\"number\">2</span>]);</div><div class=\"line\">    (*env)-&gt;ReleaseStringUTFChars(env, patch, argv[<span class=\"number\">3</span>]);</div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>并把main方法改为patchMethod，依赖<a href=\"http://www.bzip.org/1.0.6/bzip2-1.0.6.tar.gz\" target=\"_blank\" rel=\"external\">bzlib</a>，并把其中的.h和.c文件提取出来，复制到module的app/main/jni，下面会给出源码和编译好的.so文件。<br>如果发生下面错误：<br>Error:(70) multiple definition of `main’<br>提示main方法重复定义了，在出错信息中会给出哪些类中包含main方法，可以直接将这些类中的main方法直接删除。<br>再次编译就OK啦~~~</p>\n<h2 id=\"app调用\"><a href=\"#app调用\" class=\"headerlink\" title=\"app调用\"></a>app调用</h2><p>准备两个apk：<br>old.apk new.apk<br>然后服务器生成一个patch包，下面代码中的patch.patch：</p>\n<p>将old.apk安装，然后将new.apk以及patch.patch放置到存储卡(测试阶段，发布阶段需从服务器下载patch包)；<br>最后在app需要更新的地方调用增量更新：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void doBspatch() &#123;</div><div class=\"line\">    final File destApk = new File(Environment.getExternalStorageDirectory(), &quot;dest.apk&quot;);</div><div class=\"line\">    final File patch = new File(Environment.getExternalStorageDirectory(), &quot;patch.patch&quot;);</div><div class=\"line\">    BsPatch.bspatch(ApkExtract.extract(this),</div><div class=\"line\">        destApk.getAbsolutePath(),</div><div class=\"line\">        patch.getAbsolutePath());</div><div class=\"line\">    if (destApk.exists()) &#123;</div><div class=\"line\">        ApkExtract.install(this, destApk.getAbsolutePath());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>合成新的apk完成后调用系统安装，代码如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">public static void install(Context context, String apkPath) &#123;</div><div class=\"line\">    Intent i = new Intent(Intent.ACTION_VIEW);</div><div class=\"line\">    i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</div><div class=\"line\">    i.setDataAndType(Uri.fromFile(new File(apkPath)),</div><div class=\"line\">        &quot;application/vnd.android.package-archive&quot;);</div><div class=\"line\">        context.startActivity(i);</div><div class=\"line\">    android.os.Process.killProcess(android.os.Process.myPid());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><a href=\"https://github.com/wdh-1025/android-addupdate/tree/master\" target=\"_blank\" rel=\"external\">Demo地址</a></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p><a href=\"https://github.com/kingwang666/AppAddUpdate\" target=\"_blank\" rel=\"external\">AppAddUpdate</a>是别人封装好的，可以直接使用，但是建议可以自己跑一遍，不然将会失去很多学习机会，过程中或多或少会遇到很多坑，跨过去就好了…</p>\n"},{"title":"蓝牙BLE android6.0的坑","url":"http://www.68blog.cn/2016/11/03/1/","content":"<p>昨天写好蓝牙调试工具，因为一直拿着5.1的机子进行测试，没发现问题，到客户面前演示的时候，客户拿着6.0的手机安装测试，结果，蒙逼了，android6.0竟然扫不到设备，苦逼了好久，OK，开始一步步审查代码。发现<strong>startLeScan</strong>、<strong>stopLeScan</strong>这两个方法被谷歌弃用了，好吧，寻找替代的方法，结果设置参数过于麻烦。</p>\n<p>最后在“权限”上下手，想到以前跟同事说过扫描蓝牙竟然要GPS定位权限，不肥话，测试之，问题解决…</p>\n<p>因为android6.0在安全权限上做了较大的改变，所以搜索蓝牙需要在AndroidManifest.xml上添加该权限并确保你获取了该权限</p>\n<h3 id=\"Permission\"><a href=\"#Permission\" class=\"headerlink\" title=\"Permission\"></a>Permission</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">uses-permission android:name=<span class=\"string\">\"android.permission.ACCESS_COARSE_LOCATION\"</span></div></pre></td></tr></table></figure>\n"},{"title":"PHP图片批量上传","url":"http://www.68blog.cn/2015/12/07/3/","content":"<h2 id=\"总结一下PHP上传图片。\"><a href=\"#总结一下PHP上传图片。\" class=\"headerlink\" title=\"总结一下PHP上传图片。\"></a>总结一下PHP上传图片。</h2><p>上传图片原理：首先判断文件类型是否为图片格式，若是则上传文件，然后重命名文件（一般都是避免上传文件重名，现在基本上都是以为时间来命名），接着把文件上传到指定目录，成功上传后输出上传图片的预览。<br>1.首先我们开始判断文件类型是否为图片类型<br>用到的函数<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">strrchr:查找字符串在另一个字符串中最后一次出现的位置，并返回从该位置到字符串结尾的所有字符。</div><div class=\"line\">substr: 取部份字符串。</div><div class=\"line\">$HTTP_POST_FILES[<span class=\"string\">'file'</span>][<span class=\"string\">'name'</span>]:获取当前上传的文件全称。</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>图片类型就是“.”后面的字符（比如：一个文件名称为XXX.JPG 那么它的类型就是“.”后面的JPG）。 我们可以用PHP中的函数来截取上传者文件名字的。我们来写个获取文件类型的函数<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">type</span><span class=\"params\">()</span></span></div><div class=\"line\">&#123;</div><div class=\"line\"><span class=\"keyword\">return</span> substr(strrchr($HTTP_POST_FILES[<span class=\"string\">'file'</span>][<span class=\"string\">'name'</span>],<span class=\"string\">'.'</span>),<span class=\"number\">1</span>);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"meta\">?&gt;</span></div></pre></td></tr></table></figure></p>\n<p>2.若是则上传文件，然后重命名文件<br>用到的函数<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">strtolower:把字符串的字母全部转换为小写字母.</div><div class=\"line\">in_array： 函数在数组中搜索给定的值。</div><div class=\"line\">implode：函数把数组元素组合为一个字符串</div><div class=\"line\">random:随机生成的数</div><div class=\"line\">$_FILES[<span class=\"string\">'userfile'</span>][<span class=\"string\">'name'</span>]:上传文件名称</div><div class=\"line\">$uploaddir：自己定义的变量。比如在同一个文件夹里面，你想把上传的文件放到这个文件夹的FILE文件夹下，你可以这样定义$uploaddir=<span class=\"string\">\"./file/\"</span>；注意写法</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这边会出现很多问题，第一先写一个能上传类型的数组。第二判断文件合法性。第三给文件重名。*（这边判断文件大小就不写了）<br>先定义允许上传文件的类型数组：$type=array(“jpg”,”gif”,”bmp”,”jpeg”,”png”);<br>第二用一个IF。。else。。写一个判断文件合法性的控制流语句。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(!in_arry(strtolower(type()),$type))<span class=\"comment\">//如果不存在能上传的类型</span></div><div class=\"line\">&#123;</div><div class=\"line\">   $text=implode(<span class=\"string\">'.'</span>,$type);</div><div class=\"line\">   <span class=\"keyword\">echo</span> <span class=\"string\">\"您只能上传以下类型文件: \"</span>.$text.<span class=\"string\">\"&lt;br&gt;\"</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>下面就是给他们重新命名了</p>\n"},{"title":"在Windows下搭建React Native Android开发环境","url":"http://www.68blog.cn/2015/11/18/2/","content":"<h2 id=\"安装JDK\"><a href=\"#安装JDK\" class=\"headerlink\" title=\"安装JDK\"></a>安装JDK</h2><p>从<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/index-jsp-138363.html\" target=\"_blank\" rel=\"external\">Java官网</a>下载JDK并安装。请注意选择x86还是x64版本。<br>推荐将JDK的bin目录加入系统PATH环境变量。</p>\n<h2 id=\"安装Android-SDK\"><a href=\"#安装Android-SDK\" class=\"headerlink\" title=\"安装Android SDK\"></a>安装Android SDK</h2><p>可以单独安装Android SDK，也可以通过Eclipse ADT或者Android Studio一并安装。推荐使用Android Studio，以下说明会默认以Android Studio的方式说明。请注意选择x86还是x64版本。<br>为了加速下载，推荐从<a href=\"http://androiddevtools.cn/\" target=\"_blank\" rel=\"external\">AndroidDevTools</a>下载。<br>然后进入SDKManager(可通过Android Studio菜单Tools-Android-SDK Manager)，确保以下项目已经安装并更新到最新：</p>\n<ul>\n<li><p>Tools/Android SDK Tools (24.3.3)</p>\n</li>\n<li><p>Tools/Android SDK Platform-tools (22)</p>\n</li>\n<li><p>Tools/Android SDK Build-tools (23.0.1)</p>\n</li>\n<li><p>Android 6.0 (API 23)/SDK Platform (1)</p>\n</li>\n<li><p>Extras/Android Support Library(23.0.1)<br>推荐使用腾讯Bugly的镜像加速下载。<a href=\"http://android-mirror.bugly.qq.com:8080/include/usage.html\" target=\"_blank\" rel=\"external\">查看说明</a><br>推荐将SDK的platform-tools子目录加入系统PATH环境变量。</p>\n</li>\n</ul>\n<h2 id=\"安装C-环境\"><a href=\"#安装C-环境\" class=\"headerlink\" title=\"安装C++环境\"></a>安装C++环境</h2><p>推荐从<a href=\"http://msdn.itellyou.cn/\" target=\"_blank\" rel=\"external\">itellyou</a>下载并安装Visual Studio 2013或2015。也可选择Windows SDK、cygwin或mingw等其他C++环境。编译node.js的C++模块时需要用到。</p>\n<h2 id=\"安装node-js\"><a href=\"#安装node-js\" class=\"headerlink\" title=\"安装node.js\"></a>安装node.js</h2><p>从官网下载node.js的官方4.1版本或更高版本。<br>安装react-native命令行工具<br>官方的安装方法是<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g react-native-cli</div></pre></td></tr></table></figure></p>\n<p>但是由于npm上的版本在windows下存在BUG，因此需要安装github上的master支线，否则会在下一步骤报以下错误：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">This will walk you through creating a new React Native project <span class=\"keyword\">in</span> *** events.js:141       throw er; // Unhandled <span class=\"string\">'error'</span> event       ^ Error: spawn npm ENOENT     at exports._errnoException (util.js:837:11)     at Process.ChildProcess._handle.onexit (internal/child_process.js:178:32)     at onErrorNT (internal/child_process.js:344:16)     at <span class=\"keyword\">do</span>NTCallback2 (node.js:429:9)     at process._tickCallback (node.js:343:17)     at Function.Module.runMain (module.js:477:11)     at startup (node.js:117:18)     at node.js:951:3</div></pre></td></tr></table></figure></p>\n<p>如果您看到本文时0.12已经发布，那很可能直接输入上面的命令就行了。如果0.12还没有发布，请进行以下步骤：<br>在React Native的Github页面右侧点击Download ZIP，下载后解压，并执行以下代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> **解压的目录** <span class=\"built_in\">cd</span> react-native-cli npm install -g</div></pre></td></tr></table></figure></p>\n<h2 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h2><p>进入你的工作目录，运行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">react-native init MyProject</div></pre></td></tr></table></figure></p>\n<p>并耐心等待数分钟。</p>\n<h2 id=\"运行packager\"><a href=\"#运行packager\" class=\"headerlink\" title=\"运行packager\"></a>运行packager</h2><p>首先要修复package在windows下的两处BUG。</p>\n<p>1、参考这个<a href=\"https://github.com/hzerica/react-native/commits/master-pr-5\" target=\"_blank\" rel=\"external\">commit</a>，在node_modules/react-native/packager/react-packager/src/DependencyResolver/Module.js的getName()方法中，将<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">return</span> path.join(name, path.relative(p.root, this.path));</div></pre></td></tr></table></figure></p>\n<p>修改为<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">return</span> path.join(name, path.relative(p.root, this.path)).replace(/\\\\/g, <span class=\"string\">'/'</span>);</div></pre></td></tr></table></figure></p>\n<p>注意，如果你在修改此行代码之前运行过packager，那你可能需要去C:\\Users\\你的用户名\\AppData\\Local\\Temp中找到并删除所有 react-packager-cache 开头的文件。</p>\n<p>2、参考这个commit，在node_modules/react-native/packager/react-packager/src/DependencyResolver/DependencyGraph/ResolutionRequest.js的_resolveNodeDependency(fromModule, toModuleName)方法中，将<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">let</span> currDir = path.dirname(fromModule.path);                 currDir !== <span class=\"string\">'/'</span>;                 currDir = path.dirname(currDir)) &#123;</div></pre></td></tr></table></figure></p>\n<p>修改为<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (<span class=\"built_in\">let</span> currDir = path.dirname(fromModule.path);                 path.dirname(currDir) != currDir;</div></pre></td></tr></table></figure></p>\n<p>随后可以运行packager。<br>如果你有cygwin，可以在cygwin环境中进入工程目录，运行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm start</div></pre></td></tr></table></figure></p>\n<p>如果没有cygwin或不在cygwin环境中，可以进入工程目录，运行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">node node_modules\\react-native\\packager\\packager.js</div></pre></td></tr></table></figure></p>\n<p>可以用浏览器访问<a href=\"http://localhost:8081/index.android.bundle?platform=android\" target=\"_blank\" rel=\"external\">http://localhost:8081/index.android.bundle?platform=android</a>看看是否可以看到打包后的脚本。第一次访问通常需要十几秒，并且在packager的命令行可以看到进度条。如果迟迟看不到进度条，请检查上面的修改是否已经做到。</p>\n<h2 id=\"运行模拟器\"><a href=\"#运行模拟器\" class=\"headerlink\" title=\"运行模拟器\"></a>运行模拟器</h2><p>推荐使用BlueStacks不过要小心它推送的广告和垃圾应用。<br>如果有真机，可以不必运行模拟器，要配置好驱动，使得adb devices可以看到对应的设备。</p>\n<h2 id=\"安卓运行\"><a href=\"#安卓运行\" class=\"headerlink\" title=\"安卓运行\"></a>安卓运行</h2><p>保持packager开启，另外打开一个命令行窗口，然后在工程目录下运行<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">react-native run-android</div></pre></td></tr></table></figure></p>\n<p>首次运行需要等待数分钟并从网上下载gradle依赖。</p>\n<p>运行完毕后可以在模拟器或真机上看到应用自动启动了。</p>\n<p>如果gradle依赖下载出现报错，请多试几次，或者设置VPN加速。</p>\n<p>如果apk安装运行出现报错，请检查platform-tools是否已经设到了PATH环境变量中，运行adb devices能否看到设备。</p>\n<p>至此，应该能看到APP运行，并报错 Unable to download JS bundle</p>\n<p>摇晃设备或按Menu键（Bluestacks模拟器按键盘上的菜单键，通常在右Ctrl的左边 或者左Windows键旁边），可以打开调试菜单，点击Dev Settings，选Debug server host for device，输入你的局域网IP，再按back键返回，再按Menu键，在调试菜单中选择Reload JS，就应该可以看到运行的结果了。</p>\n<h2 id=\"安卓调试\"><a href=\"#安卓调试\" class=\"headerlink\" title=\"安卓调试\"></a>安卓调试</h2><p>目前Windows下无法自动打开chrome进行调试，所以手动打开chrome，访问如下地址：<a href=\"http://localhost:8081/debugger-ui\" target=\"_blank\" rel=\"external\">http://localhost:8081/debugger-ui</a> 即可。</p>\n<p>=====================================================================</p>\n<p>已按该教程搭建完成。以下是截图</p>\n<p><img src=\"http://wdh1025.ae124.zuji-08.com/upload/images/rn.jpg\" alt=\"截图\"></p>\n"},{"title":"因网站服务器迁移，文章数据暂未同步迁移","url":"http://www.68blog.cn/2015/10/17/0/","content":""},{"title":"index","url":"http://www.68blog.cn/index/index.html","content":""},{"title":"about","url":"http://www.68blog.cn/about/index.html","content":""},{"title":"link","url":"http://www.68blog.cn/link/index.html","content":""},{"title":"search","url":"http://www.68blog.cn/search/index.html","content":""},{"title":"tag","url":"http://www.68blog.cn/tag/index.html","content":""}]